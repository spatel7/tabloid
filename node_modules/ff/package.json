{
  "name": "ff",
  "version": "0.2.0",
  "description": "Concise, Powerful Asynchronous Flow Control in JavaScript",
  "engine": [
    "node >=0.2.0"
  ],
  "author": {
    "name": "Marcus Cavanaugh",
    "email": "m@mcav.com"
  },
  "contributors": [
    {
      "name": "Michael Henretty",
      "email": "michael.henretty@gmail.com"
    },
    {
      "name": "Teddy Cross",
      "email": "tkazec@gmail.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/gameclosure/ff.git"
  },
  "devDependencies": {
    "chai": "*",
    "mocha": "*",
    "promises-aplus-tests": "*"
  },
  "scripts": {
    "test": "mocha -R spec -t 5000 -s 1000 && promises-aplus-tests test/promise-adapter.js"
  },
  "main": "lib/ff",
  "readme": "# <img src=\"http://f.cl.ly/items/3K113g321o0n0W0Y0Z33/Fast%20Forward%20Icon%20in%2032x32%20px.png\" width=25 height=25> ff: Concise, Powerful Asynchronous JavaScript Flow Control [![Build Status](https://travis-ci.org/gameclosure/ff.png)](https://travis-ci.org/gameclosure/ff)\n\n***ff* simplifies the most common use cases for series, parallel, and\npromise utilities.** \n\n# Installation\n\n\t$ npm install ff\n\nIn the browser, simply add a script tag pointing to `lib/ff.js` in your HTML page.\n\n### Table of Contents\n\n- [Quick Start](#quick-start)\n- **[API Documentation](#api-documentation)**\n- [Advanced Usage](#advanced-usage)\n- [Promise API](#promise-api-deferreds)\n- **[Quick Reference & Cheat Sheet](#quick-reference--cheat-sheet)**\n\n# Quick Start\n\n`ff()` accepts a list of functions to be run in sequential order, and returns an object \nthat can be used to manage the flow of data between these functions. You may also pass in a \ncontext object as the first parameter, which FF will bind to all function calls.\n\n```javascript\nvar ff = require(\"ff\");\n\nvar f = ff(this,\n\tfunction () {\n\t\tfs.readFile(\"1.txt\", f.slot());\n\t\tfs.readFile(\"2.txt\", f.slot());\n\t},\n\tfunction (fileA, fileB) {\n\t\tthis.sortFileContents(fileA, fileB, f.slot());\n\t},\n\tfunction (result) {\n\t\tf.pass(result.toUpperCase());\n\t}\n).onComplete(nextFn);\n```\n\nFF is also [Promises/A+](http://promises-aplus.github.com/promises-spec/) compliant. For more information about using FF promises, see [below](#promise-api-deferreds).\n\n```javascript\nvar f = ff(this,\n\tfunction () {\n\t\tfs.readFile(\"1.txt\", f.slot());\n\t}\n);\n\nf.then(\n\tfunction onFulfilled(data) { }, \n\tfunction onRejected(err) { }\n);\n```\n\nA typical Express web handler looks like this. (Note that even if an\nexception gets thrown during one of these handlers, the .onError()\nhandler will be called.\n\n```javascript\nfunction (req, res, next) {\n\tvar f = ff(\n\t\tfunction() {\n\t\t\tauthenticateUser(req, f.slot());\n\t\t},\n\t\tfunction (user) {\n\t\t\tf.pass(user); // pass the user along synchronously\n\t\t\tuser.getFriends(f.slot());\n\t\t},\n\t\tfunction (user, friends) {\n\t\t\tres.json({ user: user, friends: friends });\n\t\t}\n\t).onError(next); // call next() *only* on error\n}\n```\n\n---\n\n# API Documentation\n\n### First, call `ff` and save its return value (as `f`, perhaps).\n\n```javascript\nvar f = ff([context], stepFunctions, ... )\n```\n\nThe `ff()` function takes a context and any number of\nfunctions, which we call \"steps\". Each step is run one at a time. Use\n`ff`'s return value (often called `f`) to manage the flow of data between \nfunctions.\n\n### Second, use the returned `f` object inside each step function.\n\nWithin your step functions, pass `f.slot()` as the callback parameter to\nany async function. This reserves a \"slot\" in the next step's\nfunction arguments. For instance:\n\n```javascript\nfs.readFile(\"1.txt\", f.slot()); // the file contents will be passed to the next function\n```\n\nMost often, that's all you'll need, but there are other ways to leverage \nFF to handle the flow of data.\n\n```javascript\nf.pass(data); // pass data synchronously to the next function\nfs.exists(\"1.txt\", f.slotPlain()); // fs.exists doesn't pass (err, result), just (result)\nemitter.once(\"close\", f.wait()); // just wait for the \"close\" event, don't pass any data\n```\n\n### All Methods on `f`:\n\n#### `f.slot()` aliased as `f()`\n\nCalling `f.slot()` reserves a slot in the next step's function arguments,\nand returns a callback that you should pass into an async function.\nThe async function should be called with an error as in `callback(err,\nresult)`.\n\n#### `f.pass(arg1, arg2...)` aliased as `f(arg1, arg2...)`\n\nIf you call `f.pass()`, the arguments will be passed into\nthe next step. This can be useful when you need to pass along a value\ndirectly to the next function synchronously.\n\n#### `f.wait()`\n\nSometimes you don't want to pass any arguments to the next function,\nbut you just want to wait until an async call completes successfully.\nThis behaves exactly like `f.slot()`, handling errors, but no data is\npassed to the next step.\n\n#### `f.slotPlain()`\n\nThis is like `f.slot()`, except that the resulting callback must *not*\naccept an error, as in `callback(result)`. Node's `fs.exists` doesn't\nreturn an error, for instance, and so you must use `f.slotPlain()` for\nits callback instead. (If you had used `f.slot()`, it would have\nthought `fs.exists` had passed an *error* as the first argument.\n\n#### `f.waitPlain()`\n\nSee `f.slotPlain()`. Like `f.wait()`, this does not pass any\narguments to the next step.\n\n#### `f.slotMulti(n)`\n\nLike `f.slot()`, except that the resulting callback will pass `n` arguments\nto the next step instead of just one. For instance, calling `var cb =\nf.slotMulti(2)` followed by `cb(err, rsp, body)` would pass both `rsp`\nand `body` as two arguments to the next step.\n\n#### `f.group()`\n\nThis reserves exactly one slot in the next step, and returns a group\nobject that has all of the above methods. Anything you slot or pass\ninto the group gets passed into the next function's argument list *as\nan array*. (See the [Groups example](#advanced-usage).)\n\n#### `f.succeed(successArgs...)`\n\nThis causes the chain of steps to end successfully (after you return\nfrom the current function). The result handlers (`.onSuccess()` and\n`.onComplete()`) will be called as soon as the current step returns. No other\nsteps will be executed afterward.\n\n#### `f.fail(err)`\n\nThis causes the chain of steps to end as though the given error had\noccurred (after you return from the current function). The result\nhandlers (`.onError()` and `.onComplete()`) will be called as soon as the\ncurrent step returns. No other steps will be executed afterward.\n\n#### `f.next(fn)`\n\nYou can add additional steps after calling `ff()` using `f.next(fn)`.\nInternally, we pass the arguments through this function initially.\n\n#### `f.timeout(milliseconds)`\n\nSet a timeout; if the `ff` chain of steps do not finish after this\nmany milliseconds, fail with a timeout Error. Works with both deferred\nand normal `ff` steps.\n\n### Finally, remember to handle the result! (`.onComplete`, `.onError`, `.onSuccess`)\n\nAfter you've called `ff()` with your steps, you'll want to handle the\nfinal result that gets passed down the end of the function. We often\ndo this like so:\n\n```javascript\nvar f = ff(\n   // steps here...\n).onComplete(resultHandler);\n```\n\nThat final callback will be passed arguments node-style: `onComplete(err,\nresults...)`. The number of arguments after `err` depends on how many\nslots you passed from the last function in the chain.\n\nThere are three ways you can handle the final result (and you can mix and\nmatch):\n\n#### `f.onComplete( function (err, results...) { } )`\n\nA `.onComplete()` result handler will *always* be called, whether or not an\nerror occurred. An error object will be passed first (null if there\nwas no error.)\n\n#### `f.onSuccess( function (results...) {} )`\n\nA `.onSuccess()` handler will *only* be called if no error occured.\nAdditionally, an error object will *not* be passed. Only results.\n\n#### `f.onError( function (err) {} )`\n\nA `.onError()` result handler will *only* be called if an error occured.\nIn this case, `err` will never be null. (If you're using Express,\noften we use `.onError(next)` to propagate whenever we didn't reach a\ncall to `res.send()`.)\n\n**Always remember to add one of these result handlers after your\n`ff()` call, so that errors propagate!** You can add multiple result\nhandlers and they will each be called in the order in which they were registered.\n\n### Error Handling\n\nIf any function throws an exception, or an error gets passed to one of\nthe callbacks (as in `callback(err, result)`), the error will be\npropagated immediately to your result handlers (`.onComplete()` and\n`.onError()`). If a result handler throws an exception, that exception\nwill bubble up into Node's `unhandledException` handler or the\nbrowser's developer console.\n\n---\n\n# Advanced Usage\n\n### Groups (for processing arrays)\n\nThe `f.group()` method reserves exactly one slot in the next step and\nreturns an object just like `f`. Anything you slot or pass into the\ngroup gets passed into the next function's argument list *as an\narray*. This is useful for processing arrays of items. Here's an example:\n\n```javascript\nvar allMyFiles = [\"one.txt\", \"two.txt\", \"three.txt\"];\n\nvar f = ff(\n\tfunction () {\n\t\tvar group = f.group();\n\t\tallMyFiles.forEach(function (file) {\n\t\t\tfs.readFile(file, group());\n\t\t});\n\t},\n\tfunction (allFiles) {\n\t\t// allFiles is an array of 3 items (the contents of each file).\n\n\t\t// If any call had returned an err, this function would not be\n\t\t// called, and the error would have been passed down to `onComplete`.\n\t}\n).onComplete(nextFn);\n```\n\n### Implementation Details\n\nThe following are equivalent:\n\n```javascript\nvar f = ff(this,\n\tone,\n\ttwo,\n).onComplete(three);\n```\n\n```javascript\nvar f = ff(this);\nf.next(one);\nf.next(two);\nf.onComplete(three);\n```\n\nError handling is actually quite simple: If an error occurs in any\nstep, it gets passed down to the `onComplete` or `onError` handler, skipping over any `.next` handlers.\n\n---\n\n# Promise API (Deferreds)\n\n`ff` can also be used as a promise library. If you are intersted in managing your own promises,\nyou can use the `defer` helper.\n\n```javascript\nvar f = ff.defer();\n\n// set callbacks:\nf.then(\n\tfunction onFulfilled(result, restul2) { },\n\tfunction onError(err) { }\n);\n\n// now trigger the result (or rejection)\nf(result, result2); // or f.fail(err);\n```\n\nTo trigger success or failure:\n\n```javascript\nf(arg1, arg2...) // success\nf.fail(err)      // failure\n```\n\nIn addition to using `then` to attach completion handlers, you can also use the regular \nff `.onSuccess()`, `.onError()`, and `.onComplete()` to do so.\n\nAnd just like regular `ff`, you can pass functions into `ff.defer(...)`:\n\n```javascript\nvar f = ff.defer(\n\tfunction(result, text) {\n\t\t// do something with result\n\t},\n\tfunction () {\n\t\t// ...etc...\n\t}\n);\n\nf.then(\n\tfunction onFulfilled(results) { },\n\tfunction onError(err) { };\n);\n\n// now fire the result into the first step!\nf(result, \"something else\");\n```\n\nIf you want to know more about how ff promises work, see the [Promises/A+ spec](http://promises-aplus.github.com/promises-spec/).\n\n---\n# Quick Reference / Cheat Sheet\n\nThe [API Documentation](#api-documentation) provides a much more thorough tutorial.\n\n#### Control Flow API Summary\n\n```javascript\n// Create a chain of steps with the `ff` function:\nvar f = ff(context, \n\tfunction () {\n\t\t// Within each method, use the `f` object.\n\t\t// Most common uses:\n\t\tf(arg1, arg2); // pass multiple arguments synchronously\n\t\tfs.readFile(\"file1.txt\", f());      // use f() for async callbacks\n\t\tfs.readFile(\"file2.txt\", f.wait()); // just wait for the result\n\t                                        // without putting it in args\n\t\t\t\t\t\t\t\t\t\t \n\t\t// To process arrays, use groups:\n\t\tvar group = f.group();\n\t\tallFiles.forEach(function (item) {   // use any `f` function on arrays\n\t\t    fs.readFile(item, group.slot()); // and the result gets stored as\n\t\t});                                  // an array in the next step\n\t\t\n\t\t// Less common uses for atypical functions\n\t\tfs.exists(\"file3.txt\", f.slotPlain()); // fs.exists doesn't pass an error\n\t\tfs.exists(\"file4.txt\", f.waitPlain()); // ditto, and I don't care if it fails\n\t\tvar cb = f.slotMulti(2); // slot and pass two arguments to the next function\n\t\t                         // for example, cb(null, 1, 2);\n\t\t\n\t\t// Aborting the chain of steps early:\n\t\tf.succeed(result1, ...); // after this function, skip the other steps\n\t\tf.fail(err);             // after this function, fail with this error\n\t\tf.timeout(200);\t\t\t // abort if it doesn't finish before 200 milliseconds\n\t},\n\tfunction (arg1, arg2, file1, allFiles, file3Exists, multi1, multi2) {\n\t\t// Do something amazing here!\n\t}\n).onComplete(nextFn); // <-- usually you'll have someone else handle a (err, result...) callback\n\n// Add a timeout (which would result in a failure with a timeout Error\nf.timeout(milliseconds);\n\n// Don't forget all the result handler options (attach as many as you like!)\nf.onComplete(function (err, args...) { }); // triggered on both success and error\nf.onSuccess(function (args...) { }); // only on success\nf.onError(function (err) { });       // only on error\n```\n\n#### Promise API Summary\n\n```javascript\n// Create a deferred\nvar f = ff.defer();\n\n// Add result handlers:\nf.then(\n\tfunction onFulfilled(arg1, ...) { },\n\tfunction onError(err) { };\n);\n\n// Trigger results: \nf(arg1, ...); // fulfill\nf.fail(err);  // reject\n```\n\n---\n# Acknowledgements\n\nMade by [Marcus Cavanaugh](http://mcav.com/) and [Michael Henretty](http://twitter.com/mikehenrty).\n\nThis code was originally based on\n[Tim Caswell](mailto:tim@creationix.com)'s sketch of a\n[reimagined](https://gist.github.com/1524578) [Step](https://github.com/creationix/step) library.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/gameclosure/ff/issues"
  },
  "homepage": "https://github.com/gameclosure/ff",
  "_id": "ff@0.2.0",
  "_from": "ff@~0.2.0"
}
